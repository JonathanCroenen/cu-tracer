#include <iostream>
#include "math.hu"

using namespace rt;

void test_vectors() {
    std::cout << "=== Testing Vectors ===" << std::endl;

    Vec3f v1(1, 2, 3);
    Vec3f v2(4, 5, 6);

    std::cout << "v1: " << v1 << std::endl;
    std::cout << "v2: " << v2 << std::endl;
    std::cout << "v1 + v2: " << v1 + v2 << std::endl;
    std::cout << "v1 * 2: " << v1 * 2.0f << std::endl;
    std::cout << "v1 dot v2: " << v1.dot(v2) << std::endl;
    std::cout << "v1 cross v2: " << v1.cross(v2) << std::endl;
    std::cout << "v1 length: " << v1.length() << std::endl;
    std::cout << "v1 normalized: " << v1.normalized() << std::endl;
    std::cout << std::endl;
}

void test_matrices() {
    std::cout << "=== Testing Matrices ===" << std::endl;

    Mat4f identity = Mat4f::identity();
    Mat4f translation = Mat4f::translation(1, 2, 3);
    Mat4f rotation = Mat4f::rotation_y(M_PI / 4);

    std::cout << "Identity matrix:" << std::endl << identity << std::endl;
    std::cout << "Translation matrix:" << std::endl << translation << std::endl;
    std::cout << "Rotation Y matrix (45°):" << std::endl << rotation << std::endl;

    Vec3f point(1, 0, 0);
    Vec3f transformed = rotation.transform_point(point);
    std::cout << "Point (1,0,0) rotated 45° around Y: " << transformed << std::endl;
    std::cout << std::endl;
}

void test_transforms() {
    std::cout << "=== Testing Transforms ===" << std::endl;

    Transformf t1 = Transformf::translation(1, 2, 3);
    Transformf t2 = Transformf::rotation_y(M_PI / 2);
    Transformf combined = t1 * t2;

    Vec3f point(0, 0, 1);
    Vec3f transformed = combined.transform_point(point);

    std::cout << "Point (0,0,1) transformed: " << transformed << std::endl;
    std::cout << std::endl;
}

void test_utility_functions() {
    std::cout << "=== Testing Utility Functions ===" << std::endl;

    float clamped = clamp(5.0f, 0.0f, 3.0f);
    float interpolated = lerp(0.0f, 10.0f, 0.5f);
    float smoothed = smoothstep(0.0f, 1.0f, 0.5f);

    std::cout << "clamp(5, 0, 3) = " << clamped << std::endl;
    std::cout << "lerp(0, 10, 0.5) = " << interpolated << std::endl;
    std::cout << "smoothstep(0, 1, 0.5) = " << smoothed << std::endl;
    std::cout << std::endl;
}

__global__ void test_vectors_kernel(Vec3f* results, int n) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= n)
        return;

    // Test basic vector operations
    Vec3f v1(1.0f, 2.0f, 3.0f);
    Vec3f v2(4.0f, 5.0f, 6.0f);

    Vec3f sum = v1 + v2;
    Vec3f scaled = v1 * 2.0f;
    float dot_product = v1.dot(v2);
    Vec3f cross_product = v1.cross(v2);
    Vec3f normalized = v1.normalized();

    // Store results
    results[idx * 5 + 0] = sum;
    results[idx * 5 + 1] = scaled;
    results[idx * 5 + 2] = Vec3f(dot_product, 0, 0);  // Store dot product in x component
    results[idx * 5 + 3] = cross_product;
    results[idx * 5 + 4] = normalized;
}

// CUDA kernel to test matrix operations on GPU
__global__ void test_matrices_kernel(Vec3f* results, int n) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= n)
        return;

    // Test matrix operations
    Mat4f translation = Mat4f::translation(1.0f, 2.0f, 3.0f);
    Mat4f rotation = Mat4f::rotation_y(M_PI / 4.0f);

    Vec3f point(1.0f, 0.0f, 0.0f);
    Vec3f translated = translation.transform_point(point);
    Vec3f rotated = rotation.transform_point(point);

    // Store results
    results[idx * 2 + 0] = translated;
    results[idx * 2 + 1] = rotated;
}

// Host function to test CUDA math library
void test_cuda_math() {
    std::cout << "=== Testing CUDA Math Library ===" << std::endl;

    const int num_threads = 4;
    const int num_results = num_threads * 5;  // 5 results per thread for vectors

    // Allocate host memory
    Vec3f* h_results = new Vec3f[num_results];

    // Allocate device memory
    Vec3f* d_results;
    cudaMalloc(&d_results, num_results * sizeof(Vec3f));

    // Launch vector test kernel
    int block_size = 2;
    int grid_size = (num_threads + block_size - 1) / block_size;

    std::cout << "Launching vector test kernel..." << std::endl;
    test_vectors_kernel<<<grid_size, block_size>>>(d_results, num_threads);

    // Check for errors
    cudaError_t error = cudaGetLastError();
    if (error != cudaSuccess) {
        std::cerr << "CUDA error: " << cudaGetErrorString(error) << std::endl;
        return;
    }

    // Copy results back to host
    cudaMemcpy(h_results, d_results, num_results * sizeof(Vec3f), cudaMemcpyDeviceToHost);

    // Display results from first thread
    std::cout << "Vector operations on GPU:" << std::endl;
    std::cout << "  v1 + v2 = " << h_results[0] << std::endl;
    std::cout << "  v1 * 2 = " << h_results[1] << std::endl;
    std::cout << "  v1 dot v2 = " << h_results[2].x << std::endl;
    std::cout << "  v1 cross v2 = " << h_results[3] << std::endl;
    std::cout << "  v1 normalized = " << h_results[4] << std::endl;

    // Test matrix operations
    const int num_matrix_results = num_threads * 2;
    Vec3f* h_matrix_results = new Vec3f[num_matrix_results];
    Vec3f* d_matrix_results;
    cudaMalloc(&d_matrix_results, num_matrix_results * sizeof(Vec3f));

    std::cout << "\nLaunching matrix test kernel..." << std::endl;
    test_matrices_kernel<<<grid_size, block_size>>>(d_matrix_results, num_threads);

    error = cudaGetLastError();
    if (error != cudaSuccess) {
        std::cerr << "CUDA error: " << cudaGetErrorString(error) << std::endl;
        return;
    }

    cudaMemcpy(h_matrix_results, d_matrix_results, num_matrix_results * sizeof(Vec3f),
               cudaMemcpyDeviceToHost);

    std::cout << "Matrix operations on GPU:" << std::endl;
    std::cout << "  Point (1,0,0) translated = " << h_matrix_results[0] << std::endl;
    std::cout << "  Point (1,0,0) rotated 45° = " << h_matrix_results[1] << std::endl;

    // Cleanup
    delete[] h_results;
    delete[] h_matrix_results;
    cudaFree(d_results);
    cudaFree(d_matrix_results);

    std::cout << "CUDA math library test completed successfully!" << std::endl;
    std::cout << std::endl;
}

int main() {
    std::cout << "Ray Tracer Math Library Test" << std::endl;
    std::cout << "============================" << std::endl << std::endl;

    test_vectors();
    test_matrices();
    test_transforms();
    test_utility_functions();
    test_cuda_math();

    std::cout << "All tests completed!" << std::endl;
    return 0;
}
